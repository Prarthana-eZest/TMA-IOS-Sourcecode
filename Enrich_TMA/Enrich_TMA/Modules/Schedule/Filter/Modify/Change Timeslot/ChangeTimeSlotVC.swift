//
//  ChangeTimeSlotViewController.swift
//  Enrich_TMA
//
//  Created by Harshal on 14/04/20.
//  Copyright (c) 2020 e-zest. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ChangeTimeSlotDisplayLogic: class {
    func displaySuccess<T: Decodable> (viewModel: T)
    func displayError(errorMessage: String?)
}

class SelectedDateTime {
    var selectedTime: Date = Date()
    var selectedDate: Date = Date()
}

enum PickerType {
    case dateTime, timeOnly, addAppointment, changeServiceTime
}

class ChangeTimeSlotVC: UIViewController {
    var interactor: ChangeTimeSlotBusinessLogic?
    
    // MARK: Object lifecycle
    
    @IBOutlet weak private var collectionView: UICollectionView!
    @IBOutlet weak private var lblMonthYear: UILabel!
    @IBOutlet weak private var datePicker: UIDatePicker!
    @IBOutlet weak private var btnContinue: UIButton!
    @IBOutlet weak private var lblHeader: UILabel!
    
    @IBOutlet weak private var descriptionStackView: UIStackView!
    @IBOutlet weak private var lblDuration: UILabel!
    @IBOutlet weak private var lblServicesAndPrice: UILabel!
    
    @IBOutlet weak private var lblSalonName: UILabel!
    @IBOutlet weak private var lblSalonStartTime: UILabel!
    @IBOutlet weak private var lblSalonEndTime: UILabel!
    
    private var selectedDate = Date(day: 1, hour: 0, minute: 0, second: 0)
    var dictShowDates = [SelectAppointment]()
    //  var isDateModified = false
    
    var isDateModified = false
    var selectedDateTime = SelectedDateTime()
    var onDoneBlock: ((Bool, SelectedDateTime) -> Void)?
    var pickerType: PickerType!
    
    // Add New Appointment
    var selectedCustomer: MyCustomers.GetCustomers.Customer?
    var selectedCustomerAddress: ManageAddressModule.CustomerAddress.Addresses?
    var serviceType: String = SalonServiceAt.Salon
    var appointment_id: Int64?
    var selectedServices = [MyProfile.GetServiceList.Service_list]()
    
    // Change Service Timeslot
    var selectedService: ModifyServiceCellModel?
    
    // Change Appointment Timeslot
    var appointmentDetails: Schedule.GetAppointnents.Data?
    
    var operationType: OperationType = .none

    // Change service timeslot while booking
    var defaultPickerDate = Date()
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup() {
        let viewController = self
        let interactor = ChangeTimeSlotInteractor()
        let presenter = ChangeTimeSlotPresenter()
        viewController.interactor = interactor
        interactor.presenter = presenter
        presenter.viewController = viewController
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        collectionView.register(UINib(nibName: CellIdentifier.monthCollectionViewCell, bundle: nil), forCellWithReuseIdentifier: CellIdentifier.monthCollectionViewCell)
        
        if pickerType == .dateTime {
            datePicker.isHidden = false
            collectionView.isHidden = false
            lblMonthYear.isHidden = false
            descriptionStackView.isHidden = true
            lblHeader.text = "Select the date and time"
        }
        else if pickerType == .timeOnly || pickerType == .changeServiceTime{
            datePicker.isHidden = false
            collectionView.isHidden = true
            lblMonthYear.isHidden = true
            descriptionStackView.isHidden = true
            lblHeader.text = "Select the time"
        }
        else if pickerType == .addAppointment {
            datePicker.isHidden = false
            collectionView.isHidden = false
            lblMonthYear.isHidden = false
            descriptionStackView.isHidden = false
            lblHeader.text = "Select the date and time"
            
            let duration = selectedServices.map({($0.service_time?.toInt() ?? 0)}).reduce(0, +)
            let totalSum = selectedServices.map({$0.taxable_price ?? 0.0}).reduce(0, +)
            let serviceText = selectedServices.count > 1 ? "services" : "service"
            let serviceAndPrice = String(format: "%d %@ \nâ‚¹ %@", selectedServices.count, serviceText, totalSum.cleanForPrice)
            
            lblDuration.text = GenericClass().getDurationTextFromSeconds(minuts: duration)
            lblServicesAndPrice.text = serviceAndPrice
        }
        btnContinue.isSelected = false
        
        if pickerType == .timeOnly || pickerType == .changeServiceTime
        {
            if let dateString = appointmentDetails?.appointment_date,
                let date = dateString.getDateFromString() {
                if date.dayYearMonthDate == Date().dayYearMonthDate {
                    datePicker.date = Date()
                }
                else {
                    datePicker.date = date
                }
            }
            else {
                let date = defaultPickerDate
                if date.dayYearMonthDate == Date().dayYearMonthDate {
                    datePicker.date = Date()
                }
                else {
                    datePicker.date = date
                }
            }
        }
        
        if #available(iOS 13.4, *) {
            self.datePicker.preferredDatePickerStyle = .wheels
        } else {
            // Fallback on earlier versions
        }
        
        setDataCalenderWeekMonth()
        updateContinueButtonStatue()
        
        lblSalonStartTime.isHidden = true
        lblSalonEndTime.isHidden = true
        
        if let userData = UserDefaults.standard.value(MyProfile.GetUserProfile.UserData.self, forKey: UserDefauiltsKeys.k_Key_LoginUser) {
            lblSalonName.text = userData.base_salon_name ?? ""
            lblSalonStartTime.isHidden = false
            lblSalonEndTime.isHidden = false
            lblSalonStartTime.text = userData.salon_opening_time_label ?? ""
            lblSalonEndTime.text = userData.salon_closing_time_label ?? ""
        }
    }
    
    // MARK: setDataCalenderWeekMonth
    func setDataCalenderWeekMonth() {
        
        if let date = Calendar.current.date(byAdding: .day, value: 31, to: Calendar.current.date(byAdding: .day, value: -1, to: Date())!) {
            for(index, element) in Date().allDates(till: date).enumerated() {
                if index == 0 {
                    let selectAppointment = SelectAppointment(
                        isSelected: true, year: element.OnlyYear,
                        displayWeekDate: String(format: "%@, %@ %@", element.weekdayName, element.dayDateName, element.monthName),
                        displaytime: element.timeWithPeriod,
                        dateobj: element, isLeaveOrHoliday: false,
                        leaveHolidayReason: "", isRosterCreated: true,
                        appointmentPresent: true)
                    dictShowDates.append(selectAppointment)
                }
                else {
                    
                    let selectAppointment = SelectAppointment(
                        isSelected: false, year: element.OnlyYear,
                        displayWeekDate: String(format: "%@, %@ %@", element.weekdayName, element.dayDateName, element.monthName),
                        displaytime: element.timeWithPeriod,
                        dateobj: element, isLeaveOrHoliday: false,
                        leaveHolidayReason: "", isRosterCreated: true,
                        appointmentPresent: true)
                    dictShowDates.append(selectAppointment)
                }
            }
        }
        
        collectionView.delegate = self
        collectionView.dataSource = self
        collectionView.reloadData()
        
        let MonthName: String = (dictShowDates.first?.dateobj.monthName)!
        let Year: String = (dictShowDates.first?.dateobj.OnlyYear)!
        self.lblMonthYear.text = String(format: "%@ %@", MonthName, Year)
        
        let dateFirst = dictShowDates.first?.dateobj
        selectedDate = dateFirst ?? Date()
        self.dictShowDates[0].isSelected = true
        changeDatePickerDetails(picker: self.datePicker)
    }
    
    func setDatePickerDate(dateObj: Date, dateSelected: Date) {
        for (index, model) in self.dictShowDates.enumerated() {
            if dateSelected.dayDateMonthYear == model.dateobj.dayDateMonthYear {
                self.dictShowDates[index].isSelected = true
            }
            else {
                self.dictShowDates[index].isSelected = false
            }
        }
        self.selectedDate = dateSelected
        self.collectionView.reloadData()
        let date = Calendar.current.date(byAdding: .minute, value: 0, to: dateObj)
        self.datePicker.setDate(date ?? Date(), animated: false)
        updateContinueButtonStatue()
    }
    
    func updateContinueButtonStatue() {
        // let order = Calendar.current.compare(datePicker.date, to: Date(), toGranularity: .day)
        btnContinue.isSelected = true//(order == .orderedAscending || order == .orderedSame) ? true : false
    }
    
    // MARK: - IBActions
    @IBAction func dateChange(_ sender: Any) {
        if let picker = sender as? UIDatePicker {
            isDateModified = true
            changeDatePickerDetails(picker: picker)
        }
    }
    
    func changeDatePickerDetails(picker: UIDatePicker) {
        let order = Calendar.current.compare((self.dictShowDates.first(where: {$0.isSelected == true})?.dateobj)!, to: Date(), toGranularity: .day)
        var dateFirst = Date()
        var dateSecond = Date(day: 1, hour: 0, minute: 0, second: 0)
        if pickerType == .addAppointment,
            serviceType == SalonServiceAt.Salon {
            dateFirst = Calendar.current.date(byAdding: .minute, value: 05, to: Date()) ?? Date()
            dateSecond = Calendar.current.date(byAdding: .minute, value: 05, to: dateSecond) ?? Date()
        }
        
        picker.minimumDate = (order == .orderedAscending || order == .orderedSame) ? dateFirst : dateSecond
        
        datePicker.date = picker.date
        selectedDateTime.selectedTime = picker.date
        updateContinueButtonStatue()
    }
    
    @IBAction func clickClose(_ sender: Any) {
        onDoneBlock?(false, selectedDateTime)
        self.dismiss(animated: true, completion: nil)
    }
    
    @IBAction func clickContinue(_ sender: Any) {
        
        if pickerType == .addAppointment {
            if serviceType == SalonServiceAt.Salon {
                addSalonAppointment()
            }
            else {
                addHomeAppointment()
            }
        }
        else if pickerType == .timeOnly {
            if operationType == .addSingleService {
                if serviceType == SalonServiceAt.Salon {
                    addSalonAppointment()
                }
                else {
                    changeServiceTimeSlot()
                }
            }else {
                changeServiceTimeSlot()
            }
        }
        else if pickerType == .dateTime {
            changeAppointmentTimeSlot()
        }
        else if pickerType == .changeServiceTime{
            onDoneBlock?(true, selectedDateTime)
            self.dismiss(animated: true, completion: nil)
        }
        else {
            onDoneBlock?(isDateModified, selectedDateTime)
            self.dismiss(animated: true, completion: nil)
        }
    }
    
    func addSalonAppointment() {
        let vc = SelectStylistAndTimeslotVC.instantiate(fromAppStoryboard: .BookAppointment)
        self.selectedServices[0].startTime = selectedDateTime.selectedTime.startTime
        vc.selectedServices = selectedServices
        vc.selectedDateTime = self.selectedDateTime
        vc.selectedCustomer = self.selectedCustomer
        vc.appointmentDetails = appointmentDetails
        vc.operationType = operationType
        vc.selectedCustomerAddress = self.selectedCustomerAddress
        self.present(vc, animated: true, completion: nil)
        vc.onDoneBlock = { [unowned self] (status) in
            if status {
                self.onDoneBlock?(status, self.selectedDateTime)
                self.dismiss(animated: true, completion: nil)
            }
        }
    }
    
    func addHomeAppointment() {
        addBlankAppointment()
    }
}

extension ChangeTimeSlotVC: ChangedTechnicianDelegate {
    func getChangedTechnicianDetails(arrTechniciansSlots: [StylistAvailable.GetAvailableList.StartEndTimeModel], technicianData: StylistAvailable.GetAvailableList.ResponseDataTechnician, indexPath: IndexPath, rate: Double) {
        
    }
    
}

// MARK: -
extension ChangeTimeSlotVC: UICollectionViewDataSource, UICollectionViewDelegate, UICollectionViewDelegateFlowLayout {
    
    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return self.dictShowDates.count
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        
        guard let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CellIdentifier.monthCollectionViewCell, for: indexPath) as? MonthCollectionViewCell else {
            return UICollectionViewCell()
        }
        
        let date: String = self.dictShowDates[indexPath.row].dateobj.dayDateName
        let weekName: String = self.dictShowDates[indexPath.row].dateobj.weekdayName
        cell.lblWeek.text = weekName
        cell.lblDate.text = date
        cell.indexPath = indexPath
        cell.lblDate.backgroundColor = .white
        cell.lblDate.textColor = UIColor.black
        cell.lblDate.layer.borderColor = self.dictShowDates[indexPath.row].isSelected ? UIColor.red.cgColor : UIColor.clear.cgColor
        
        if self.dictShowDates[indexPath.row].isSelected {
            cell.lblDate.textColor = UIColor.white
            cell.lblDate.backgroundColor = .red
        }
        return cell
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        return CGSize(width: self.collectionView.bounds.width / 5, height: 60)
    }
    
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {
        getChangedDate(indexPath: indexPath)
    }
    
    func alertForError(indexPath: IndexPath) {
        let alertObj = UIAlertController(title: "", message: AlertMessagesToAsk.askForChangeTechnicians, preferredStyle: .alert)
        alertObj.addAction(UIAlertAction(title: AlertButtonTitle.yes, style: .default, handler: { (_) in
            self.getChangedDate(indexPath: indexPath)
            self.isDateModified = true
        }))
        alertObj.addAction(UIAlertAction(title: AlertButtonTitle.no, style: .cancel, handler: { (_) in
        }))
        self.present(alertObj, animated: true, completion: nil)
    }
    
    func getChangedDate(indexPath: IndexPath) {
        let MonthName: String = self.dictShowDates[indexPath.row].dateobj.monthName
        let Year: String = self.dictShowDates[indexPath.row].dateobj.OnlyYear
        self.lblMonthYear.text = String(format: "%@ %@", MonthName, Year)
        for(index, _) in self.dictShowDates.enumerated() {
            self.dictShowDates[index].isSelected = false
        }
        self.dictShowDates[indexPath.row].isSelected = true
        selectedDate = self.dictShowDates[indexPath.row].dateobj
        selectedDateTime.selectedDate = selectedDate
        self.collectionView.reloadData()
        changeDatePickerDetails(picker: datePicker)
    }
}

// MARK: - SelectAppointmentDisplayLogic
extension ChangeTimeSlotVC: ChangeTimeSlotDisplayLogic {
    
    // API Request
    func addBlankAppointment() {
        if let userData = UserDefaults.standard.value(MyProfile.GetUserProfile.UserData.self, forKey: UserDefauiltsKeys.k_Key_LoginUser),
            let customer = selectedCustomer {
            
            EZLoadingActivity.show("Loading...", disableUI: true)
            
            let tech_name = "\(userData.firstname ?? "") \(userData.lastname ?? "")"
            
            var address = ""
            var landmark: String?
            if let addressDetails = selectedCustomerAddress {
                address = String(format: "%@, %@- %@, %@",
                                 addressDetails.street?.joined(separator: ", ") ?? "",
                                 addressDetails.city ?? "",
                                 addressDetails.postcode ?? "",
                                 addressDetails.region?.region ?? "")
                if addressDetails.street?.count ?? 0 > 1 {
                    landmark = addressDetails.street?.last
                }
            }
            
            let requestDetails = ChangeTimeSlot.AddBlank.RequestDetails(customer_id: customer.id, employee_id: userData.employee_id, service_at: serviceType.lowercased(), appointment_date: selectedDateTime.selectedDate.dayYearMonthDate, salon_id: userData.salon_id, customer_contact: customer.mobile_number, customer_name: customer.firstname, customer_last_name: customer.lastname, customer_gender: customer.gender, inclined_other_gender: customer.inclined_other_gender, customer_address1: address, landmark: landmark ,salon_code: userData.base_salon_code, technician_name: tech_name)
            
            let request = ChangeTimeSlot.AddBlank.Request(addData: requestDetails, is_custom: true)
            
            interactor?.doPostAddBlankAppointment(request: request)
        }
    }
    
    func addServices(appointment_id: Int64) {
        
        if let userData = UserDefaults.standard.value(MyProfile.GetUserProfile.UserData.self, forKey: UserDefauiltsKeys.k_Key_LoginUser),
            let customer = selectedCustomer {
            
            EZLoadingActivity.show("Loading...", disableUI: true)
            
            var address = ""
            if let addressDetails = selectedCustomerAddress {
                address = String(format: "%@, %@ - %@, %@",
                                 addressDetails.street?.joined(separator: ", ") ?? "",
                                 addressDetails.city ?? "",
                                 addressDetails.postcode ?? "",
                                 addressDetails.region?.region ?? "")
                
            }
            
            var services = [ChangeTimeSlot.AddMultipleServices.RequestData]()
            
            // Old Code
            //var startDate = selectedDateTime.selectedTime
            
            // New Code
            var startTime = selectedDateTime.selectedTime.startTime
            
            
            selectedServices.forEach {
                services.append(ChangeTimeSlot.AddMultipleServices.RequestData(
                    service_id: $0.service_id,
                    service_code: $0.service_code,
                    service_name: $0.name,
                    service_category: $0.service_category,
                    service_duration: $0.service_time ?? "0",
                    buffer_time: $0.buffer_time ?? "0",
                    price: "\($0.taxable_price ?? 0)",
                    employee_id: userData.employee_id,
                    start_time: startTime,
                    end_time: "",
                    technician: nil,
                    customer_gender: customer.gender,
                    inclined_other_gender: customer.inclined_other_gender,
                    customer_name: customer.firstname,
                    customer_last_name: customer.lastname,
                    customer_contact: customer.mobile_number,
                    customer_address1: address,
                    customer_address2: "",
                    customer_email: customer.email,
                    customer_id: customer.id,
                    dependant_age: nil,
                    dependant_gender: nil,
                    dependant_name: nil,
                    dependant_note: nil,
                    dependant_id: nil,
                    is_dependant: nil,
                    override: nil,
                    parent_item_id: $0.parent_item_id,
                    parent_sku: $0.parent_sku,
                    parent_name: $0.parent_name,
                    product_type: $0.product_type,
                    is_consultation_required: $0.is_consultation_required))
                
                // Old Code
                //let duration = ($0.service_time ?? "0").toInt() ?? 0
                //startDate = startDate.getStartDateFromEnd(minutes: duration)
                
                // New Code
                startTime = ""
            }
            
            let requestDetails = ChangeTimeSlot.AddMultipleServices.RequestDetails(salon_id: userData.salon_id, appointment_id: appointment_id, services: services, multiple_service: 0)
            
            let request = ChangeTimeSlot.AddMultipleServices.Request(addData: requestDetails, is_custom: true)
            
            interactor?.doPostAddMultipleServices(request: request)
        }
    }
    
    func changeServiceTimeSlot() {
        
        if let userData = UserDefaults.standard.value(MyProfile.GetUserProfile.UserData.self, forKey: UserDefauiltsKeys.k_Key_LoginUser),
            let service = selectedService,
            let customer_id = service.customer_id {
            
            EZLoadingActivity.show("Loading...", disableUI: true)
            
            let startTime = selectedDateTime.selectedTime.startTime
            let endTime = selectedDateTime.selectedTime.getEndDateFromStart(minutes: service.duration + service.bufferTime)
            
            let requestDetails = ModifyAppointment.ChangeTimeslot.RequestDetails(ref_id: "\(service.ref_id)", request_category: ModifyAppointmentCatagories.changeServiceTimeslot, employee_id: userData.employee_id, module_name: "service", start_time: startTime, end_time: endTime, customer_id: "\(customer_id)")
            
            let request = ModifyAppointment.ChangeTimeslot.Request(addData: requestDetails, is_custom: true)
            
            interactor?.doPostChangeServiceTimeslot(request: request, method: .post)
        }
    }
    
    func changeAppointmentTimeSlot() {
        
        if let userData = UserDefaults.standard.value(MyProfile.GetUserProfile.UserData.self, forKey: UserDefauiltsKeys.k_Key_LoginUser),
            let appointment = appointmentDetails,
            let customer_id = appointment.services?.first?.booked_for_id {
            
            EZLoadingActivity.show("Loading...", disableUI: true)
            
            let startDate = selectedDateTime.selectedDate.dayYearMonthDate
            let startTime = selectedDateTime.selectedTime.startTime
            let endTime = "" //selectedDateTime.selectedTime.getEndDateFromStart(minutes: service.duration)
            
            let requestDetails = ModifyAppointment.ChangeTimeslot.RequestDetails(
                ref_id: "\(appointment.appointment_id ?? 0)",
                request_category: ModifyAppointmentCatagories.changeAppointmentTimeslot,
                employee_id: userData.employee_id,
                module_name: "appointment",
                start_time: "\(startDate) \(startTime)",
                end_time: endTime, customer_id: "\(customer_id)")
            
            let request = ModifyAppointment.ChangeTimeslot.Request(addData: requestDetails, is_custom: true)
            
            interactor?.doPostChangeAppointmentTimeslot(request: request, method: .post)
        }
    }
    
    // API Response
    func displaySuccess<T>(viewModel: T) where T: Decodable {
        EZLoadingActivity.hide()
        
        if let model = viewModel as? ChangeTimeSlot.AddBlank.Response {
            if model.status == true,
                let id = model.data?.id {
                appointment_id = id
                addServices(appointment_id: id)
            }
            else {
                showAlert(alertTitle: "", alertMessage: model.message ?? "Unable to create appointment")
            }
        }
        else if let model = viewModel as? ChangeTimeSlot.AddMultipleServices.Response {
            
            let alertController = UIAlertController(title: alertTitle, message: model.message ?? "", preferredStyle: UIAlertController.Style.alert)
            alertController.addAction(UIAlertAction(title: AlertButtonTitle.ok, style: UIAlertAction.Style.cancel) { _ -> Void in
                if model.status == true {
                    self.onDoneBlock?(true, self.selectedDateTime)
                    self.dismiss(animated: true, completion: nil)
                }
            })
            self.present(alertController, animated: true, completion: nil)
        }
        else if let model = viewModel as? ModifyAppointment.ChangeTimeslot.Response {
            let alertController = UIAlertController(title: alertTitle, message: model.message, preferredStyle: UIAlertController.Style.alert)
            alertController.addAction(UIAlertAction(title: AlertButtonTitle.ok, style: UIAlertAction.Style.cancel) { _ -> Void in
                if model.status == true {
                    self.onDoneBlock?(true, self.selectedDateTime)
                    self.dismiss(animated: true, completion: nil)
                }
            })
            self.present(alertController, animated: true, completion: nil)
        }
    }
    
    func displayError(errorMessage: String?) {
        EZLoadingActivity.hide()
        showAlert(alertTitle: "", alertMessage: errorMessage ?? "Error while adding details")
    }
}
