//
//  ConfirmCustomerOTPViewController.swift
//  Enrich_TMA
//
//  Created by Harshal Patil on 26/12/19.
//  Copyright (c) 2019 e-zest. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol ConfirmCustomerOTPDisplayLogic: class {
    func displaySuccess<T: Decodable> (viewModel: T)
    func displayError(errorMessage: String?)
}

enum OTPType: String {
    case belitaOTP = "belita"
    case paymentOTP = "payment"
}

class ConfirmCustomerOTPVC: UIViewController, ConfirmCustomerOTPDisplayLogic {
    var interactor: ConfirmCustomerOTPBusinessLogic?

    @IBOutlet weak private var txtFieldOTP: CustomTextField!
    @IBOutlet weak private var lblOTPTimer: UILabel!
    @IBOutlet weak private var btnResendCode: UIButton!
    @IBOutlet weak private var btnSubmit: UIButton!

    // MARK: Object lifecycle

    var viewDismissBlock: ((Bool) -> Void)?

    var confirmationType: OTPType?

    var cardId = ""

    var appointmentDetails: Schedule.GetAppointnents.Data?

    //Timer Variables
    weak var countdownTimer: Timer!
    var totalTime = 60

    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }

    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }

    // MARK: Setup

    private func setup() {
        let viewController = self
        let interactor = ConfirmCustomerOTPInteractor()
        let presenter = ConfirmCustomerOTPPresenter()
        viewController.interactor = interactor
        interactor.presenter = presenter
        presenter.viewController = viewController
    }

    // MARK: View lifecycle

    override func viewDidLoad() {
        super.viewDidLoad()
       // if confirmationType != .belitaOTP {
        resendOTP()
       // }
//        else {
//            self.startTimer()
//        }
        hideKeyboardWhenTappedAround()
        [txtFieldOTP].forEach({ $0.addTarget(self, action: #selector(editingChanged), for: .editingChanged) })
        txtFieldOTP.delegate = self
        btnSubmit.isUserInteractionEnabled = true
    }

    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        UserFactory.shared.checkForSignOut()
        AppDelegate.OrientationLock.lock(to: UIInterfaceOrientationMask.portrait,
                                         andRotateTo: UIInterfaceOrientation.portrait)
        navigationController?.addCustomBackButton(title: "")
        KeyboardAnimation.sharedInstance.beginKeyboardObservation(self.view)
        KeyboardAnimation.sharedInstance.extraBottomSpace = 100
    }

    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)
        hideKeyboard()
        KeyboardAnimation.sharedInstance.endKeyboardObservation()
    }

    func clearData() {
        self.txtFieldOTP.text = ""
    }

    // MARK: IBActions

    @IBAction func clickResendCode(_ sender: Any) {
        resendOTP()
    }

    @IBAction func clickToSubmit(_ sender: Any) {
        txtFieldOTP.resignFirstResponder()
        OTPVerification()
    }

    @IBAction func clickClose(_ sender: UIButton) {
        self.dismiss(animated: true) {
            self.viewDismissBlock?(false)
        }
    }

    // MARK: Call Webservice

    func resendOTP() {
        if let appointment = appointmentDetails,
            let appointmentId = appointment.appointment_id,
            let customerId = appointment.services?.first?.booked_for_id,
            let type = confirmationType {

            EZLoadingActivity.show("Loading...", disableUI: true)

            if type == .belitaOTP {
                let request = ConfirmCustomerOTP.ResendOTP.BelitaRequest(appointment_id: "\(appointmentId)", customer_id: "\(customerId)", type: type.rawValue, is_custom: "1")
                interactor?.doResendBelitaOTP(accessToken: self.getAccessToken(), request: request)
            }
            else if type == .paymentOTP {
                let request = ConfirmCustomerOTP.ResendOTP.PaymentRequest(appointment_id: "\(appointmentId)", customer_id: "\(customerId)", type: type.rawValue, is_custom: "1", quote_id: self.cardId)
                interactor?.doResendPaymentOTP(accessToken: self.getAccessToken(), request: request)
            }

        }
    }

    func OTPVerification() {
        if let appointment = appointmentDetails,
            let appointmentId = appointment.appointment_id,
            let type = confirmationType {

            EZLoadingActivity.show("Loading...", disableUI: true)

            let request = ConfirmCustomerOTP.ConfirmOTP.Request(appointment_id: "\(appointmentId)", otp: "\(txtFieldOTP.text ?? "")", type: type.rawValue, is_custom: "1")
            interactor?.doConfirmOTP(accessToken: self.getAccessToken(), request: request)
        }
    }

    // MARK: PassData

    func displaySuccess<T: Decodable>(viewModel: T) {

        EZLoadingActivity.hide()

        if let model = viewModel as? ConfirmCustomerOTP.ResendOTP.Response {
            print("Response:\(model)")
            if model.status {
                self.clearData()
                self.startTimer()
            }
            self.showAlert(alertTitle: alertTitle, alertMessage: model.message)

        }
        else if let model = viewModel as? ConfirmCustomerOTP.ConfirmOTP.Response {
            print("Response:\(model)")
            if model.status == true, model.verified == true {

                self.dismiss(animated: true) {
                    self.viewDismissBlock?(true)
                }
            }
            else {
                self.showAlert(alertTitle: alertTitle, alertMessage: model.message)
            }
        }

    }

    func displayError(errorMessage: String?) {
        DispatchQueue.main.async { [unowned self] in
            EZLoadingActivity.hide()
            self.showAlert(alertTitle: alertTitle, alertMessage: errorMessage ?? "")
        }
    }
}

extension ConfirmCustomerOTPVC: UITextFieldDelegate {
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        textField.resignFirstResponder()
        return true
    }

}

extension ConfirmCustomerOTPVC {
    @objc func editingChanged(_ textField: UITextField) {
        btnSubmit.isEnabled = false
        btnSubmit.isSelected = true
        let otp = (txtFieldOTP.text ?? "").trim()

        if otp.count >= 4 {
            btnSubmit.isEnabled = true
            btnSubmit.isSelected = true
        }
    }
}

extension ConfirmCustomerOTPVC {
    // MARK: Timer
    func startTimer() {
        btnResendCode.isUserInteractionEnabled = false
        lblOTPTimer.text = "0:00 sec"
        countdownTimer = Timer.scheduledTimer(timeInterval: 1, target: self, selector: #selector(updateTime), userInfo: nil, repeats: true)
        btnResendCode.setTitleColor(UIColor.lightGray, for: .normal)
    }
    @objc func updateTime() {
        lblOTPTimer.text = "\(timeFormatted(totalTime))"
        if totalTime != 0 {
            totalTime -= 1

        }
        else {
            endTimer()
        }
    }
    func endTimer() {
        lblOTPTimer.text = "0:00 sec"
        countdownTimer.invalidate()
        totalTime = 60
        btnResendCode.isUserInteractionEnabled = true
        btnResendCode.setTitleColor(UIColor.black, for: .normal)
    }

    func timeFormatted(_ totalSeconds: Int) -> String {
        let seconds: Int = totalSeconds % 60
        let minutes: Int = (totalSeconds / 60) % 60
        //     let hours: Int = totalSeconds / 3600
        return String(format: "%01d:%02d secs", minutes, seconds)
    }
}
