//
//  SelectStylistAndTimeslotViewController.swift
//  Enrich_TMA
//
//  Created by Harshal on 17/11/20.
//  Copyright (c) 2020 e-zest. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol SelectStylistAndTimeslotDisplayLogic: class
{
    func displaySuccess<T: Decodable> (viewModel: T)
    func displayError(errorMessage: String?)
}

class SelectStylistAndTimeslotVC: UIViewController, SelectStylistAndTimeslotDisplayLogic
{
    var interactor: SelectStylistAndTimeslotBusinessLogic?
    
    @IBOutlet weak var btnViewAllRecommended: UIButton!
    @IBOutlet weak var lblDate: LabelButton!
    @IBOutlet weak var lblTime: UILabel!
    @IBOutlet weak private var tableView: UITableView!
    @IBOutlet weak var lblCartViewHours: UILabel!
    @IBOutlet weak var lblCartViewServicesAndAmount: UILabel!
    @IBOutlet weak var btnContinue: UIButton!
    @IBOutlet weak var btnChangeTime: UIButton!
    var appointment_id: Int64?
    var servicesWithTimeslot = [SelectStylistAndTimeslot.ServicesWithTimeslot.ResponseModel]()
    var selectedCustomer: MyCustomers.GetCustomers.Customer?
    var selectedServices = [MyProfile.GetServiceList.Service_list]()
    var selectedCustomerAddress: ManageAddressModule.CustomerAddress.Addresses?
    var selectedDateTime = SelectedDateTime()
    
    // Final service list after selecting technician
    var serviceList = [ServiceAndStylistModel]()
    
    // Add Single Service
    var appointmentDetails: Schedule.GetAppointnents.Data?
    
    var operationType: OperationType = .addSingleService
    var backView = UIView()
    
    var onDoneBlock: ((Bool) -> Void)?
    
    // MARK: Object lifecycle
    
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?)
    {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    
    required init?(coder aDecoder: NSCoder)
    {
        super.init(coder: aDecoder)
        setup()
    }
    
    // MARK: Setup
    
    private func setup()
    {
        let viewController = self
        let interactor = SelectStylistAndTimeslotInteractor()
        let presenter = SelectStylistAndTimeslotPresenter()
        viewController.interactor = interactor
        interactor.presenter = presenter
        presenter.viewController = viewController
    }
    
    
    // MARK: View lifecycle
    
    override func viewDidLoad()
    {
        super.viewDidLoad()
        tableView.register(UINib(nibName: CellIdentifier.stylistDetailsCell, bundle: nil), forCellReuseIdentifier: CellIdentifier.stylistDetailsCell)
        callGetServiceList()
        tableView.separatorInset = UIEdgeInsets(top: 0, left: UIScreen.main.bounds.width, bottom: 0, right: 0)
        backView.frame = self.view.frame
        backView.backgroundColor = .black
        self.view.addSubview(backView)
        self.view.bringSubviewToFront(backView)
        backView.isHidden = true
    }
    
    override func viewDidAppear(_ animated: Bool) {
        super.viewDidAppear(animated)
        showTimeAndData()
    }
    
    func showTimeAndData() {
        var finalAmount = 0.0
        var timeForServices = 0
        for model in selectedServices {
            finalAmount = finalAmount + (model.taxable_price ?? 0.0)
            timeForServices = timeForServices + (Int(model.service_time ?? "0") ?? 0)
        }
        self.lblCartViewServicesAndAmount.text = "\(selectedServices.count) Services \n\(finalAmount)"
        self.lblCartViewHours.text = GenericClass().getDurationTextFromSeconds(minuts: timeForServices)

        if operationType == .addMultipleServices {
            self.lblDate.text = self.selectedDateTime.selectedDate.dayMonthDate
        }
        else if operationType == .addSingleService {
            if let dateString = appointmentDetails?.appointment_date,
                let date = dateString.getDateFromString() {
                self.lblDate.text = date.dayMonthDate
            }
        }
    }
    
    
    //@IBOutlet weak var nameTextField: UITextField!
    @IBAction func actionChangeTiming(_ sender: Any) {
        self.dismiss(animated: true, completion: nil)
    }
    
    @IBAction func clickClose(_ sender: Any) {
        self.dismiss(animated: true, completion: nil)
    }
    
    @IBAction func actionBtnContinue(_ sender: Any) {
        if validationsForTechnician() {
            if operationType == .addMultipleServices {
                addBlankAppointment()
            }
            else if operationType == .addSingleService {
                //addSingleServiceAPICall()
                addServicesToExistingAppointment()
            }
        }
    }
    
    func validationsForTechnician() -> Bool {
        // All technicians selected
        for model in serviceList {
            if model.technician == nil || model.technician == 0 {
                showAlert(alertTitle: "", alertMessage: serviceList.count > 1 ? "Please select all the technicians" : "Please select the technician")
                return false
            }
            if (model.servicing_technician_available ?? "").lowercased() == "no", (model.override == nil || model.override == 0) {
                showAlert(alertTitle: "", alertMessage: "Technician is not available for \(model.name ?? "") at selected timeslot. Please select another timeslot or override the timeslot")
                return false
            }
            // All time selected
            if (model.startTime ?? "" ).isEmpty || model.startTime == nil || (model.endTime ?? "").isEmpty || model.endTime == nil {
                showAlert(alertTitle: "", alertMessage: "Please select timings for services")
                return false
            }
        }
        return true
    }
}

// MARK: - Call Webservice
extension SelectStylistAndTimeslotVC {
    
    func callGetServiceList() {
        
        if let userData = UserDefaults.standard.value(MyProfile.GetUserProfile.UserData.self, forKey: UserDefauiltsKeys.k_Key_LoginUser) {
            
            EZLoadingActivity.show("", disableUI: true)
            
            var services = [SelectStylistAndTimeslot.ServicesWithTimeslot.RequestData]()
            selectedServices.forEach {
                services.append(SelectStylistAndTimeslot.ServicesWithTimeslot.RequestData(
                    is_dependant: $0.dependant_id == nil ? nil : 1,
                    dependant_id: $0.dependant_id,
                    service_id: $0.service_id,
                    start_time: $0.startTime,
                    service_duration: $0.service_time))
            }
            
            let request = SelectStylistAndTimeslot.ServicesWithTimeslot.Request(
                employee_code: userData.employee_code,
                services: services)
            interactor?.doPostRequestGetServiceListWithTimeslot(request: request)
            
        }
    }
    
    // MARK: -
    func displaySuccess<T: Decodable> (viewModel: T) {
        EZLoadingActivity.hide()
        
        if let model = viewModel as? SelectStylistAndTimeslot.ServicesWithTimeslot.Response, let dataObj = model.data, let serviceObj = dataObj.services {
            self.servicesWithTimeslot.removeAll()
            self.servicesWithTimeslot.append(contentsOf: serviceObj)
            serviceMapping()
            
        }
        else if let model = viewModel as? [SelectStylistAndTimeslot.ServicesWithTimeslot.ResponseModel] {
            self.servicesWithTimeslot.removeAll()
            self.servicesWithTimeslot.append(contentsOf: model)
            serviceMapping()
        }
        else if let model = viewModel as? ChangeTimeSlot.AddBlank.Response {
            if model.status == true,
                let id = model.data?.id {
                self.appointment_id = id
                self.addServicesToNewAppointment(appointment_id: self.appointment_id!)
            }
            else {
                showAlert(alertTitle: "", alertMessage: model.message ?? "Unable to create appointment")
            }
        }
        else if let model = viewModel as? ChangeTimeSlot.AddMultipleServices.Response {
            let alertController = UIAlertController(title: alertTitle, message: model.message ?? "", preferredStyle: UIAlertController.Style.alert)
            alertController.addAction(UIAlertAction(title: AlertButtonTitle.ok, style: UIAlertAction.Style.cancel) { _ -> Void in
                if model.status == true {
                    self.dismiss(animated: true, completion: nil)
                    self.onDoneBlock?(true)
                }
            })
            self.present(alertController, animated: true, completion: nil)
        }
        else if let model = viewModel as? ModifyAppointment.AddSingleService.Response {
            let alertController = UIAlertController(title: alertTitle, message: model.message, preferredStyle: UIAlertController.Style.alert)
            alertController.addAction(UIAlertAction(title: AlertButtonTitle.ok, style: UIAlertAction.Style.cancel) { _ -> Void in
                if model.status == true {
                    self.dismiss(animated: true, completion: nil)
                    self.onDoneBlock?(true)
                }
            })
            self.present(alertController, animated: true, completion: nil)
        }
        
    }
    
    func displayError(errorMessage: String?) {
        EZLoadingActivity.hide()
        showAlert(alertTitle: "", alertMessage: errorMessage ?? "Unable to create appointment")
    }
    
    func serviceMapping() {
        
        self.serviceList.removeAll()
        
        selectedServices.forEach {
            let serviceObject = ServiceAndStylistModel()
            serviceObject.service_id = $0.service_id
            serviceObject.dependant_id = $0.dependant_id
            
            let modelObj = self.servicesWithTimeslot.filter { (modelObj) -> Bool in
                return modelObj.service_id == serviceObject.service_id && modelObj.dependant_id == serviceObject.dependant_id
            }.last
            serviceObject.entity_id = $0.entity_id
            serviceObject.type_id = $0.type_id
            serviceObject.name = $0.name
            serviceObject.price = $0.price
            serviceObject.taxable_price = $0.taxable_price
            serviceObject.buffer_time = $0.buffer_time
            serviceObject.service_code = $0.service_code
            serviceObject.store_id = $0.store_id
            serviceObject.min_price = $0.min_price
            serviceObject.max_price = $0.max_price
            serviceObject.service_category = $0.service_category
            serviceObject.service_time = $0.service_time
            serviceObject.parent_item_id = $0.parent_item_id
            serviceObject.parent_name = $0.parent_name
            serviceObject.parent_sku = $0.parent_sku
            serviceObject.product_type = $0.product_type
            serviceObject.is_consultation_required = $0.is_consultation_required
            serviceObject.bundle_parent_id = $0.bundle_parent_id
            serviceObject.configurable_parent_id = $0.configurable_parent_id
            serviceObject.startTime = modelObj?.start_time
            serviceObject.endTime = modelObj?.end_time
            serviceObject.dependant_name = $0.dependant_name
            serviceObject.is_dependant_service = (($0.dependant_id == nil || $0.dependant_id == 0) ? 0 : 1)
            serviceObject.dependant_gender = $0.dependant_gender
            serviceObject.dependant_age = $0.dependant_age
            serviceObject.dependant_note = $0.dependant_note
            
            if operationType == .addSingleService {
                let originalCustomer = appointmentDetails?.services?.first?.booked_for ?? ""
                serviceObject.customer_name = $0.dependant_id == nil ? originalCustomer : $0.dependant_name
            }else if operationType == .addMultipleServices {
                serviceObject.customer_name = $0.dependant_id == nil ? ((selectedCustomer?.firstname ?? "") + " " + (selectedCustomer?.lastname ?? "")) : $0.dependant_name
            }
            serviceObject.gender = $0.gender
            serviceList.append(serviceObject)
            tableView.reloadData()
        }
    }
    
    func openDateTimePicker(stylistId: String, indexPath: IndexPath) {
        let vc = ChangeTimeSlotVC.instantiate(fromAppStoryboard: .Schedule)
        backView.isHidden = false
        backView.alpha = screenPopUpAlpha
        self.view.alpha = 1.0
        vc.pickerType = .changeServiceTime
        vc.defaultPickerDate = selectedDateTime.selectedDate
        self.present(vc, animated: true, completion: nil)
        vc.onDoneBlock = { [unowned self] (result, dateTime) in
            if result {
                
                let serviceTime = self.serviceList[indexPath.section].service_time ?? "0"
                let startTime = dateTime.selectedTime.startTime
                let endTime = dateTime.selectedTime.getEndDateFromStart(minutes: Int(serviceTime) ?? 0)
                print("Service Time: \(serviceTime)")
                print("New Time: \(startTime)")
                print("End Time: \(endTime)")
                
                self.serviceList[indexPath.section].technician = nil
                self.serviceList[indexPath.section].startTime = startTime
                self.serviceList[indexPath.section].endTime = endTime
                self.serviceList[indexPath.section].override = 0
                self.serviceList[indexPath.section].dictForTimes.removeAll()
                self.serviceList[indexPath.section].dictForTimes = [:]
                self.serviceList[indexPath.section].servicing_technician_available = nil
                DispatchQueue.main.async {
                    self.tableView.reloadData()
                }
            }
            self.backView.alpha = 1.0
            self.backView.isHidden = true
        }
    }
}

extension SelectStylistAndTimeslotVC: StylistDetailsDelegate {
    
    func actionChangeTime(stylistId: String, indexPath: IndexPath) {
        openDateTimePicker(stylistId: stylistId, indexPath: indexPath)
    }
    
    func actionOverride(sender: UIButton) {
        let dataObj = serviceList[sender.tag] // Technician data change in codable model
        dataObj.override = sender.isSelected ? 1 : 0
        //dataObj.dictForTimes.removeAll()
        //dataObj.dictForTimes = [:]
        serviceList[sender.tag] = dataObj
        DispatchQueue.main.async {
            self.tableView.reloadData()
        }
    }
    
    func actionChange(stylistId: String, indexPath: IndexPath) {
        openChangeStylist(indexPath: indexPath)
    }
    
    func actionServiceDelete(stylistId: String, indexPath: IndexPath) {
    }
    
    func openChangeStylist(indexPath: IndexPath) {
        let slotObj = serviceList[indexPath.section]
        let vcStylistAvailable = StylistAvailableVC.instantiate(fromAppStoryboard: .BookAppointment)
        vcStylistAvailable.modelAppointment = slotObj
        vcStylistAvailable.delegate = self
        vcStylistAvailable.selectedParentIndex = indexPath
        vcStylistAvailable.service_at = "salon"
        if operationType == .addMultipleServices {
            vcStylistAvailable.selectedDateTime = self.selectedDateTime.selectedDate.dayYearMonthDate
        }
        else if operationType == .addSingleService {
            if let dateString = appointmentDetails?.appointment_date,
                let date = dateString.getDateFromString() {
                vcStylistAvailable.selectedDateTime = date.dayYearMonthDate
            }
        }
        if let userData = UserDefaults.standard.value(MyProfile.GetUserProfile.UserData.self, forKey: UserDefauiltsKeys.k_Key_LoginUser) {
            vcStylistAvailable.salon_code = userData.base_salon_code!
        }
        self.navigationController?.isNavigationBarHidden = false
        self.present(vcStylistAvailable, animated: false, completion: nil)
        vcStylistAvailable.onDoneBlock = { result in
            if result {
                
            }
            else {}
        }
    }
}

extension SelectStylistAndTimeslotVC: ChangedTechnicianDelegate {
    func getChangedTechnicianDetails(arrTechniciansSlots: [StylistAvailable.GetAvailableList.StartEndTimeModel], technicianData: StylistAvailable.GetAvailableList.ResponseDataTechnician, indexPath: IndexPath, rate: Double) {
        
        let dataObj = serviceList[indexPath.section] // Technician data change in codable model
        serviceList[indexPath.section] = dataObj
        
        if (technicianData.available ?? "").lowercased() != AlertButtonTitle.yes.lowercased() { // Available slot change do in sections
            var arrTimeSlots: [String] = []
            for model in arrTechniciansSlots {
                arrTimeSlots.append("\(model.start_time ?? "") - \(model.end_time ?? "")")
            }

                                
            let model = StylistDetailsCellModel(title: "", amountAndtime: "", id: Int64(indexPath.section), profilePictureURL: "", userName: "", level: "", rating: 0, isPreferred: false, location: "", isAvailable: true, isGender: 0, availableTimeSlots: arrTimeSlots, gender: "", parentName: "", showParentName: false, parentItemId: "", parentItemSKU: "", technicianRate: 0, employee_health_status: "", employee_last_screening: "", serviceType: "" )

            let leftMargin: CGFloat = 10
            let cellHeight: CGFloat = 60
            let cellWidth = 180.0
            let headerHeight: CGFloat = 60

            let font = UIFont(name: FontName.FuturaPTDemi.rawValue, size: is_iPAD ? 24 : 16)
            let modelObj = SectionConfiguration(
                title: SectionIdentifier.check_Available_TimeSlot.rawValue,
                subTitle: "",
                cellHeight: cellHeight,
                cellWidth: CGFloat(cellWidth),
                showHeader: true,
                showFooter: false,
                headerHeight: headerHeight,
                footerHeight: 0,
                leftMargin: leftMargin,
                rightMarging: 0,
                isPagingEnabled: false,
                textFont: font,
                textColor: .black,
                items: arrTimeSlots.count,
                identifier: .check_Available_TimeSlot,
                data: [model],
                selectedIndex: -1
            )

            dataObj.dictForTimes["\(indexPath.section)"] = modelObj
        }
        dataObj.servicing_technician_available = technicianData.available
        dataObj.servicing_technician = technicianData.technician
        dataObj.technician = technicianData.employee_id ?? 0
        dataObj.servicing_technician_code = ""
        dataObj.servicing_technician_gender = technicianData.gender
        dataObj.servicing_technician_designation = technicianData.designation_name
        dataObj.servicing_technician_designation_id = technicianData.designation_id

        dataObj.rating = technicianData.rating
        dataObj.rate = rate

        serviceList[indexPath.section] = dataObj
        self.btnContinue.setTitle("Continue".uppercased(), for: .normal)
        DispatchQueue.main.async {
            self.tableView.reloadData()
        }
    }
    
    // API Request
    func addBlankAppointment() {

        if self.appointment_id == nil || self.appointment_id != 0 {
            if let userData = UserDefaults.standard.value(MyProfile.GetUserProfile.UserData.self, forKey: UserDefauiltsKeys.k_Key_LoginUser),
                let customer = selectedCustomer {

                EZLoadingActivity.show("Loading...", disableUI: true)

                let tech_name = "\(userData.firstname ?? "") \(userData.lastname ?? "")"

                var address = ""
                var landmark: String?
                if let addressDetails = selectedCustomerAddress {
                    address = String(format: "%@, %@- %@, %@",
                                     addressDetails.street?.joined(separator: ", ") ?? "",
                                     addressDetails.city ?? "",
                                     addressDetails.postcode ?? "",
                                     addressDetails.region?.region ?? "")
                    if addressDetails.street?.count ?? 0 > 1 {
                        landmark = addressDetails.street?.last
                    }
                }

                let requestDetails = ChangeTimeSlot.AddBlank.RequestDetails(
                    customer_id: customer.id,
                    employee_id: userData.employee_id,
                    service_at: "salon",
                    appointment_date: self.selectedDateTime.selectedDate.dayYearMonthDate,
                    salon_id: userData.salon_id,
                    customer_contact: customer.mobile_number,
                    customer_name: customer.firstname,
                    customer_last_name: customer.lastname,
                    customer_gender: customer.gender,
                    inclined_other_gender: customer.inclined_other_gender,
                    customer_address1: address,
                    landmark: landmark,
                    salon_code: userData.base_salon_code,
                    technician_name: tech_name)

                let request = ChangeTimeSlot.AddBlank.Request(addData: requestDetails, is_custom: true)
                interactor?.doPostAddBlankAppointment(request: request)
            }
        }
    }
    
    func addServicesToNewAppointment(appointment_id: Int64) {
        
        if let userData = UserDefaults.standard.value(MyProfile.GetUserProfile.UserData.self, forKey: UserDefauiltsKeys.k_Key_LoginUser),
            let customer = selectedCustomer {
            
            EZLoadingActivity.show("Loading...", disableUI: true)
            
            var address = ""
            if let addressDetails = selectedCustomerAddress {
                address = String(format: "%@, %@ - %@, %@",
                                 addressDetails.street?.joined(separator: ", ") ?? "",
                                 addressDetails.city ?? "",
                                 addressDetails.postcode ?? "",
                                 addressDetails.region?.region ?? "")
            }
            
            var services = [ChangeTimeSlot.AddMultipleServices.RequestData]()
            serviceList.forEach {
                let modelObj = ChangeTimeSlot.AddMultipleServices.RequestData(
                    service_id: $0.service_id,
                    service_code: $0.service_code,
                    service_name: $0.name,
                    service_category: $0.service_category,
                    service_duration: $0.service_time,
                    buffer_time: $0.buffer_time,
                    price: "\($0.taxable_price ?? 0)",
                    employee_id: userData.employee_id,
                    start_time: $0.startTime,
                    end_time: $0.endTime,
                    technician: $0.technician,
                    customer_gender: customer.gender,
                    inclined_other_gender: customer.inclined_other_gender,
                    customer_name: customer.firstname,
                    customer_last_name: customer.lastname,
                    customer_contact: customer.mobile_number,
                    customer_address1: address,
                    customer_address2: "",
                    customer_email: customer.email,
                    customer_id: customer.id,
                    dependant_age: $0.dependant_age,
                    dependant_gender: $0.dependant_gender,
                    dependant_name: $0.dependant_name,
                    dependant_note: $0.dependant_note,
                    dependant_id: $0.dependant_id,
                    is_dependant: (($0.dependant_id == nil || $0.dependant_id == 0) ? 0 : 1),
                    override: $0.override,
                    parent_item_id: $0.parent_item_id,
                    parent_sku: $0.parent_sku,
                    parent_name: $0.parent_name,
                    product_type: $0.product_type,
                    is_consultation_required: $0.is_consultation_required)

                 services.append(modelObj)
            }
            let requestDetails = ChangeTimeSlot.AddMultipleServices.RequestDetails(salon_id: userData.salon_id, appointment_id: appointment_id, services: services, multiple_service: operationType == .addSingleService ? 1 : 0)
            let request = ChangeTimeSlot.AddMultipleServices.Request(addData: requestDetails, is_custom: true)
            interactor?.doPostAddMultipleServices(request: request)
        }
    }
    
    func addServicesToExistingAppointment() {
        
        if let userData = UserDefaults.standard.value(MyProfile.GetUserProfile.UserData.self, forKey: UserDefauiltsKeys.k_Key_LoginUser),
            let details = appointmentDetails,
            let appointment_id = details.appointment_id {
            
            EZLoadingActivity.show("Loading...", disableUI: true)
            
            var address = ""
            if let addressDetails = selectedCustomerAddress {
                address = String(format: "%@, %@ - %@, %@",
                                 addressDetails.street?.joined(separator: ", ") ?? "",
                                 addressDetails.city ?? "",
                                 addressDetails.postcode ?? "",
                                 addressDetails.region?.region ?? "")
            }
            
            var services = [ChangeTimeSlot.AddMultipleServices.RequestData]()
            serviceList.forEach {
                let modelObj = ChangeTimeSlot.AddMultipleServices.RequestData(
                    service_id: $0.service_id,
                    service_code: $0.service_code,
                    service_name: $0.name,
                    service_category: $0.service_category,
                    service_duration: $0.service_time,
                    buffer_time: $0.buffer_time,
                    price: "\($0.taxable_price ?? 0)",
                    employee_id: userData.employee_id,
                    start_time: $0.startTime,
                    end_time: $0.endTime,
                    technician: $0.technician,
                    customer_gender: "\(details.gender ?? 1)",
                    inclined_other_gender: details.inclined_other_gender,
                    customer_name: details.customer_firstname,
                    customer_last_name: details.customer_lastname,
                    customer_contact: details.customer_mobile_number,
                    customer_address1: address,
                    customer_address2: "",
                    customer_email: details.customer_email,
                    customer_id: "\(details.services?.first?.booked_for_id ?? 0)",
                    dependant_age: $0.dependant_age,
                    dependant_gender: $0.dependant_gender,
                    dependant_name: $0.dependant_name,
                    dependant_note: $0.dependant_note,
                    dependant_id: $0.dependant_id,
                    is_dependant: (($0.dependant_id == nil || $0.dependant_id == 0) ? 0 : 1),
                    override: $0.override,
                    parent_item_id: $0.parent_item_id,
                    parent_sku: $0.parent_sku,
                    parent_name: $0.parent_name,
                    product_type: $0.product_type,
                    is_consultation_required: $0.is_consultation_required)

                 services.append(modelObj)
            }
            let requestDetails = ChangeTimeSlot.AddMultipleServices.RequestDetails(salon_id: userData.salon_id, appointment_id: appointment_id, services: services, multiple_service: operationType == .addSingleService ? 1 : 0)
            let request = ChangeTimeSlot.AddMultipleServices.Request(addData: requestDetails, is_custom: true)
            interactor?.doPostAddMultipleServices(request: request)
        }
    }
    
    func addSingleServiceAPICall() {
        
        if let userData = UserDefaults.standard.value(MyProfile.GetUserProfile.UserData.self, forKey: UserDefauiltsKeys.k_Key_LoginUser),
            let details = appointmentDetails,
            let newService = serviceList.first {
            
            EZLoadingActivity.show("Loading...", disableUI: true)
                        
            let requestDetails = ModifyAppointment.AddSingleService.RequestDetails(
                start_time: newService.startTime,
                end_time: newService.endTime,
                appointment_id: details.appointment_id,
                salon_id: userData.salon_id,
                service_id: newService.service_id,
                price: newService.taxable_price,
                nonTaxablePrice: nil,
                employee_id: userData.employee_id,
                technician: "\(newService.technician ?? 0)",
                service_name: newService.name,
                service_code: newService.service_code,
                service_category: newService.service_category,
                service_duration: newService.service_time,
                buffer_time: newService.buffer_time,
                serviceGender: "",
                customer_name: details.customer_firstname,
                customer_last_name: details.customer_lastname,
                customer_contact: details.customer_mobile_number,
                customer_id: "\(details.services?.first?.booked_for_id ?? 0)",
                customer_address1: details.customer_address,
                customer_address2: details.customer_address2,
                appointment_type: "self",
                customer_gender: "\(details.gender ?? 1)",
                inclined_other_gender: details.inclined_other_gender,
                request_category: ModifyAppointmentCatagories.addService,
                parent_item_id: newService.parent_item_id,
                parent_sku: newService.parent_sku,
                parent_name: newService.parent_name,
                product_type: newService.product_type,
                is_dependant: ((newService.dependant_id == nil || newService.dependant_id == 0) ? 0 : 1),
                override: newService.override,
                dependant_id: newService.dependant_id,
                dependant_name: newService.dependant_name,
                dependant_age: newService.dependant_age,
                dependant_gender: newService.dependant_gender,
                dependant_note: newService.dependant_note,
                is_consultation_required: newService.is_consultation_required)
            
            let request = ModifyAppointment.AddSingleService.Request(addData: requestDetails, is_custom: true)
            
            interactor?.doPostAddSingleService(request: request, method: .post)
        }
    }
}

extension SelectStylistAndTimeslotVC: UITableViewDelegate, UITableViewDataSource {
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return serviceList.count
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        let modelObj = serviceList[section]
        if  modelObj.dictForTimes.count > 0, (modelObj.servicing_technician_available ?? "").lowercased() == "no", modelObj.override != 1  {
            return 2
        }
        return 1
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        
        let modelObj = serviceList[indexPath.section]
        if  modelObj.dictForTimes.count > 0, (modelObj.servicing_technician_available ?? "").lowercased() == "no", indexPath.row == 1, modelObj.override != 1 {
            guard let cell = tableView.dequeueReusableCell(withIdentifier: CellIdentifier.productsCollectionCell, for: indexPath) as? ProductsCollectionCell else {
                return UITableViewCell()
            }
            cell.tableViewIndexPath = indexPath
            cell.selectedMenuCell = 1
            cell.confirmStylistDelegate = self
            cell.configureCollectionView(configuration: modelObj.dictForTimes["\(indexPath.section)"]!, scrollDirection: .horizontal)
            cell.selectionStyle = .none
            cell.separatorInset = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0)
            return cell
        }
        
        guard let cell = tableView.dequeueReusableCell(withIdentifier: CellIdentifier.stylistDetailsCell, for: indexPath) as? StylistDetailsCell else {
            return UITableViewCell()
        }
        cell.delegate = self
        cell.indexPath = indexPath
        cell.btnOverride.tag = indexPath.section
        cell.configureCell(model:modelObj )
        if (modelObj.servicing_technician_available ?? "").lowercased() == "no" {
            cell.stackViewOverride.isHidden = false
            if modelObj.dictForTimes.count > 0, (modelObj.override == nil || modelObj.override == 0) {
                cell.stackViewTimeSlotLabel.isHidden = false
                cell.separatorInset = UIEdgeInsets(top: 0, left: UIScreen.main.bounds.width, bottom: 0, right: 0)
            }else {
                cell.stackViewTimeSlotLabel.isHidden = true
                cell.separatorInset = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0)
            }
        } else {
            cell.stackViewOverride.isHidden = true
            cell.stackViewTimeSlotLabel.isHidden = true
            cell.separatorInset = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0)
        }
        cell.selectionStyle = .none
        return cell
        
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        let modelObj = serviceList[indexPath.section]
        if modelObj.dictForTimes.count > 0 && indexPath.row == 1 {
            return 60
        }
        return UITableView.automaticDimension
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
    }
}

extension SelectStylistAndTimeslotVC: ConfirmStylistDelegate {
    func selectedTimeSlot(stylistId: String, indexpath: IndexPath) {
        print("stylistId : \(stylistId)")
        print("indexpath : \(indexpath.row)")
        
        let modelObj = self.serviceList[Int(stylistId) ?? 0]
        if let modelDictObj = modelObj.dictForTimes["\(stylistId)"], let dataObj = modelDictObj.data as? [StylistDetailsCellModel] {
            print("stylistId : \(dataObj[0].availableTimeSlots[indexpath.row])")
            
            let arrSlots = dataObj[0].availableTimeSlots[indexpath.row].components(separatedBy: " - ")
            if !arrSlots.isEmpty {
                let strStrat = arrSlots.first
                let strStrat_time = strStrat?.getTimeInDate().startTime.trim() //.time24Only.trim()
                let strEnd = arrSlots.last
                let strEnd_time = strEnd?.getTimeInDate().startTime.trim()
                modelObj.startTime = strStrat_time
                modelObj.endTime = strEnd_time
                modelObj.override = 0
                modelObj.servicing_technician_available = nil
                modelObj.dictForTimes.removeAll()
                modelObj.dictForTimes = [:]
                serviceList[Int(stylistId) ?? 0] = modelObj
                DispatchQueue.main.async {
                    self.tableView.reloadData()
                }
            }
        }
    }
}
